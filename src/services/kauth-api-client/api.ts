/* tslint:disable */
/* eslint-disable */
/**
 * KAuth
 * REST API for KAuth service
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuthenticateAuthenticateRequest
 */
export interface AuthenticateAuthenticateRequest {
    /**
     * Password is the password for the user
     * @type {string}
     * @memberof AuthenticateAuthenticateRequest
     */
    'password': string;
    /**
     * Username is the name of the user to authenticate
     * @type {string}
     * @memberof AuthenticateAuthenticateRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface ClientconfigClientConfigResponse
 */
export interface ClientconfigClientConfigResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ClientconfigClientConfigResponse
     */
    'require-registration-access-code'?: boolean;
}
/**
 * 
 * @export
 * @interface EmailverificationsVerifyRequest
 */
export interface EmailverificationsVerifyRequest {
    /**
     * Token is an email verification token
     * @type {string}
     * @memberof EmailverificationsVerifyRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface EmailverificationsVerifyResponse
 */
export interface EmailverificationsVerifyResponse {
    /**
     * 
     * @type {string}
     * @memberof EmailverificationsVerifyResponse
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {Array<ModelError>}
     * @memberof ErrorResponse
     */
    'errors'?: Array<ModelError>;
}
/**
 * 
 * @export
 * @interface ErrorSource
 */
export interface ErrorSource {
    /**
     * Parameter is a string indicating which URI query parameter caused the error
     * @type {string}
     * @memberof ErrorSource
     */
    'parameter'?: string;
    /**
     * Pointer is a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. \"/data\" for a primary data object, or \"/data/attributes/title\" for a specific attribute]
     * @type {string}
     * @memberof ErrorSource
     */
    'pointer'?: string;
}
/**
 * 
 * @export
 * @interface InvitesAcceptRequest
 */
export interface InvitesAcceptRequest {
    /**
     * Password is the user\'s new password
     * @type {string}
     * @memberof InvitesAcceptRequest
     */
    'password': string;
    /**
     * Token is an invitation token
     * @type {string}
     * @memberof InvitesAcceptRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Code is an application-specific error code, expressed as a string value.
     * @type {string}
     * @memberof ModelError
     */
    'code'?: string;
    /**
     * Detail is a human-readable explanation specific to this occurrence of the problem. Like title, this fieldâ€™s value can be localized.
     * @type {string}
     * @memberof ModelError
     */
    'detail'?: string;
    /**
     * ID is a unique identifier for this particular occurrence of the problem.
     * @type {string}
     * @memberof ModelError
     */
    'id'?: string;
    /**
     * 
     * @type {ErrorSource}
     * @memberof ModelError
     */
    'source'?: ErrorSource;
    /**
     * Status is the HTTP status code applicable to this problem, expressed as a string value.
     * @type {string}
     * @memberof ModelError
     */
    'status'?: string;
    /**
     * Title is a short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
     * @type {string}
     * @memberof ModelError
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface PasswordresetsRequestResetRequest
 */
export interface PasswordresetsRequestResetRequest {
    /**
     * Email is the email of the user requesting a password reset
     * @type {string}
     * @memberof PasswordresetsRequestResetRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface PasswordresetsResetRequest
 */
export interface PasswordresetsResetRequest {
    /**
     * Password is the user\'s new password
     * @type {string}
     * @memberof PasswordresetsResetRequest
     */
    'password': string;
    /**
     * Token is a password reset token
     * @type {string}
     * @memberof PasswordresetsResetRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface RegisterRegisterRequest
 */
export interface RegisterRegisterRequest {
    /**
     * Email is the email of the new user
     * @type {string}
     * @memberof RegisterRegisterRequest
     */
    'email': string;
    /**
     * FirstName is the first name of the new user
     * @type {string}
     * @memberof RegisterRegisterRequest
     */
    'firstName': string;
    /**
     * LastName is the last name of the new user
     * @type {string}
     * @memberof RegisterRegisterRequest
     */
    'lastName': string;
    /**
     * Organization is the name of the new organization to create
     * @type {string}
     * @memberof RegisterRegisterRequest
     */
    'organization': string;
    /**
     * Password is the password of the new user
     * @type {string}
     * @memberof RegisterRegisterRequest
     */
    'password': string;
    /**
     * Registration Code is the code required to register a new user
     * @type {string}
     * @memberof RegisterRegisterRequest
     */
    'registration-code'?: string;
}
/**
 * 
 * @export
 * @interface RegisterRegisterResponse
 */
export interface RegisterRegisterResponse {
    /**
     * 
     * @type {string}
     * @memberof RegisterRegisterResponse
     */
    'organizationID'?: string;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will authenticate a user...
         * @summary Authenticates a user given a username and password
         * @param {AuthenticateAuthenticateRequest} message Authentication request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticatePost: async (message: AuthenticateAuthenticateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('authenticatePost', 'message', message)
            const localVarPath = `/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh will set a new access and refresh token if the user is still valid.
         * @summary Refreshes a user if a valid refresh token is provided
         * @param {object} message refresh request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPost: async (message: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('refreshPost', 'message', message)
            const localVarPath = `/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * This will authenticate a user...
         * @summary Authenticates a user given a username and password
         * @param {AuthenticateAuthenticateRequest} message Authentication request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticatePost(message: AuthenticateAuthenticateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticatePost(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh will set a new access and refresh token if the user is still valid.
         * @summary Refreshes a user if a valid refresh token is provided
         * @param {object} message refresh request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshPost(message: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshPost(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * This will authenticate a user...
         * @summary Authenticates a user given a username and password
         * @param {AuthenticateAuthenticateRequest} message Authentication request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticatePost(message: AuthenticateAuthenticateRequest, options?: any): AxiosPromise<object> {
            return localVarFp.authenticatePost(message, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh will set a new access and refresh token if the user is still valid.
         * @summary Refreshes a user if a valid refresh token is provided
         * @param {object} message refresh request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPost(message: object, options?: any): AxiosPromise<object> {
            return localVarFp.refreshPost(message, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * This will authenticate a user...
     * @summary Authenticates a user given a username and password
     * @param {AuthenticateAuthenticateRequest} message Authentication request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticatePost(message: AuthenticateAuthenticateRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticatePost(message, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh will set a new access and refresh token if the user is still valid.
     * @summary Refreshes a user if a valid refresh token is provided
     * @param {object} message refresh request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public refreshPost(message: object, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refreshPost(message, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientConfigApi - axios parameter creator
 * @export
 */
export const ClientConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * this endpoint will check if the `require-registration-access-code` has been set in the config
         * @summary returns a json with wether the require-registration-access-code (bool) has been set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/client-config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientConfigApi - functional programming interface
 * @export
 */
export const ClientConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * this endpoint will check if the `require-registration-access-code` has been set in the config
         * @summary returns a json with wether the require-registration-access-code (bool) has been set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientConfigGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientconfigClientConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientConfigGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientConfigApi - factory interface
 * @export
 */
export const ClientConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientConfigApiFp(configuration)
    return {
        /**
         * this endpoint will check if the `require-registration-access-code` has been set in the config
         * @summary returns a json with wether the require-registration-access-code (bool) has been set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientConfigGet(options?: any): AxiosPromise<ClientconfigClientConfigResponse> {
            return localVarFp.clientConfigGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientConfigApi - object-oriented interface
 * @export
 * @class ClientConfigApi
 * @extends {BaseAPI}
 */
export class ClientConfigApi extends BaseAPI {
    /**
     * this endpoint will check if the `require-registration-access-code` has been set in the config
     * @summary returns a json with wether the require-registration-access-code (bool) has been set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientConfigApi
     */
    public clientConfigGet(options?: AxiosRequestConfig) {
        return ClientConfigApiFp(this.configuration).clientConfigGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If the organization has an IdP setup, they will be redirected through that IdP, otherwise they will be redirected to the Konnect user login
         * @summary Redirects a user to the correct location for organization
         * @param {string} organizationId Organization ID
         * @param {string} [returnTo] Path to return to after authentication has completed
         * @param {string} [test] Configuration test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateOrganizationIdGet: async (organizationId: string, returnTo?: string, test?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('authenticateOrganizationIdGet', 'organizationId', organizationId)
            const localVarPath = `/authenticate/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnTo !== undefined) {
                localVarQueryParameter['returnTo'] = returnTo;
            }

            if (test !== undefined) {
                localVarQueryParameter['test'] = test;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * If the organization has an IdP setup, they will be redirected through that IdP, otherwise they will be redirected to the Konnect user login
         * @summary Redirects a user to the correct location for organization
         * @param {string} organizationId Organization ID
         * @param {string} [returnTo] Path to return to after authentication has completed
         * @param {string} [test] Configuration test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateOrganizationIdGet(organizationId: string, returnTo?: string, test?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateOrganizationIdGet(organizationId, returnTo, test, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * If the organization has an IdP setup, they will be redirected through that IdP, otherwise they will be redirected to the Konnect user login
         * @summary Redirects a user to the correct location for organization
         * @param {string} organizationId Organization ID
         * @param {string} [returnTo] Path to return to after authentication has completed
         * @param {string} [test] Configuration test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateOrganizationIdGet(organizationId: string, returnTo?: string, test?: string, options?: any): AxiosPromise<void> {
            return localVarFp.authenticateOrganizationIdGet(organizationId, returnTo, test, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * If the organization has an IdP setup, they will be redirected through that IdP, otherwise they will be redirected to the Konnect user login
     * @summary Redirects a user to the correct location for organization
     * @param {string} organizationId Organization ID
     * @param {string} [returnTo] Path to return to after authentication has completed
     * @param {string} [test] Configuration test mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public authenticateOrganizationIdGet(organizationId: string, returnTo?: string, test?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).authenticateOrganizationIdGet(organizationId, returnTo, test, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EmailVerificationApi - axios parameter creator
 * @export
 */
export const EmailVerificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint verifies a user\'s email given an email verification token.
         * @summary Verifies a user\'s email address
         * @param {EmailverificationsVerifyRequest} message Verify email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailVerificationsPatch: async (message: EmailverificationsVerifyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('emailVerificationsPatch', 'message', message)
            const localVarPath = `/email-verifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailVerificationApi - functional programming interface
 * @export
 */
export const EmailVerificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmailVerificationApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint verifies a user\'s email given an email verification token.
         * @summary Verifies a user\'s email address
         * @param {EmailverificationsVerifyRequest} message Verify email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailVerificationsPatch(message: EmailverificationsVerifyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailverificationsVerifyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailVerificationsPatch(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EmailVerificationApi - factory interface
 * @export
 */
export const EmailVerificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmailVerificationApiFp(configuration)
    return {
        /**
         * This endpoint verifies a user\'s email given an email verification token.
         * @summary Verifies a user\'s email address
         * @param {EmailverificationsVerifyRequest} message Verify email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailVerificationsPatch(message: EmailverificationsVerifyRequest, options?: any): AxiosPromise<EmailverificationsVerifyResponse> {
            return localVarFp.emailVerificationsPatch(message, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmailVerificationApi - object-oriented interface
 * @export
 * @class EmailVerificationApi
 * @extends {BaseAPI}
 */
export class EmailVerificationApi extends BaseAPI {
    /**
     * This endpoint verifies a user\'s email given an email verification token.
     * @summary Verifies a user\'s email address
     * @param {EmailverificationsVerifyRequest} message Verify email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailVerificationApi
     */
    public emailVerificationsPatch(message: EmailverificationsVerifyRequest, options?: AxiosRequestConfig) {
        return EmailVerificationApiFp(this.configuration).emailVerificationsPatch(message, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvitesApi - axios parameter creator
 * @export
 */
export const InvitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint accepts an invitation and sets the user\'s initial password. It will also mark the user\'s email address as verified.
         * @summary Accepts an invitation
         * @param {InvitesAcceptRequest} message Verify email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesPatch: async (message: InvitesAcceptRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('invitesPatch', 'message', message)
            const localVarPath = `/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitesApi - functional programming interface
 * @export
 */
export const InvitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitesApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint accepts an invitation and sets the user\'s initial password. It will also mark the user\'s email address as verified.
         * @summary Accepts an invitation
         * @param {InvitesAcceptRequest} message Verify email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitesPatch(message: InvitesAcceptRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitesPatch(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvitesApi - factory interface
 * @export
 */
export const InvitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitesApiFp(configuration)
    return {
        /**
         * This endpoint accepts an invitation and sets the user\'s initial password. It will also mark the user\'s email address as verified.
         * @summary Accepts an invitation
         * @param {InvitesAcceptRequest} message Verify email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesPatch(message: InvitesAcceptRequest, options?: any): AxiosPromise<object> {
            return localVarFp.invitesPatch(message, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitesApi - object-oriented interface
 * @export
 * @class InvitesApi
 * @extends {BaseAPI}
 */
export class InvitesApi extends BaseAPI {
    /**
     * This endpoint accepts an invitation and sets the user\'s initial password. It will also mark the user\'s email address as verified.
     * @summary Accepts an invitation
     * @param {InvitesAcceptRequest} message Verify email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public invitesPatch(message: InvitesAcceptRequest, options?: AxiosRequestConfig) {
        return InvitesApiFp(this.configuration).invitesPatch(message, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordsApi - axios parameter creator
 * @export
 */
export const PasswordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint updates a user\'s password given a reset token.
         * @summary Resets a user\'s password
         * @param {PasswordresetsResetRequest} message Reset Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordResetsPatch: async (message: PasswordresetsResetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('passwordResetsPatch', 'message', message)
            const localVarPath = `/password-resets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint creates a reset request entry and sends the user an email with a link to reset their password. It will return success if the email address is not found.
         * @summary Creates a password reset request
         * @param {PasswordresetsRequestResetRequest} message Request Reset Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordResetsPost: async (message: PasswordresetsRequestResetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('passwordResetsPost', 'message', message)
            const localVarPath = `/password-resets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordsApi - functional programming interface
 * @export
 */
export const PasswordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint updates a user\'s password given a reset token.
         * @summary Resets a user\'s password
         * @param {PasswordresetsResetRequest} message Reset Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passwordResetsPatch(message: PasswordresetsResetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passwordResetsPatch(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint creates a reset request entry and sends the user an email with a link to reset their password. It will return success if the email address is not found.
         * @summary Creates a password reset request
         * @param {PasswordresetsRequestResetRequest} message Request Reset Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passwordResetsPost(message: PasswordresetsRequestResetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passwordResetsPost(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordsApi - factory interface
 * @export
 */
export const PasswordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordsApiFp(configuration)
    return {
        /**
         * This endpoint updates a user\'s password given a reset token.
         * @summary Resets a user\'s password
         * @param {PasswordresetsResetRequest} message Reset Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordResetsPatch(message: PasswordresetsResetRequest, options?: any): AxiosPromise<object> {
            return localVarFp.passwordResetsPatch(message, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint creates a reset request entry and sends the user an email with a link to reset their password. It will return success if the email address is not found.
         * @summary Creates a password reset request
         * @param {PasswordresetsRequestResetRequest} message Request Reset Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordResetsPost(message: PasswordresetsRequestResetRequest, options?: any): AxiosPromise<object> {
            return localVarFp.passwordResetsPost(message, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PasswordsApi - object-oriented interface
 * @export
 * @class PasswordsApi
 * @extends {BaseAPI}
 */
export class PasswordsApi extends BaseAPI {
    /**
     * This endpoint updates a user\'s password given a reset token.
     * @summary Resets a user\'s password
     * @param {PasswordresetsResetRequest} message Reset Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordsApi
     */
    public passwordResetsPatch(message: PasswordresetsResetRequest, options?: AxiosRequestConfig) {
        return PasswordsApiFp(this.configuration).passwordResetsPatch(message, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint creates a reset request entry and sends the user an email with a link to reset their password. It will return success if the email address is not found.
     * @summary Creates a password reset request
     * @param {PasswordresetsRequestResetRequest} message Request Reset Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordsApi
     */
    public passwordResetsPost(message: PasswordresetsRequestResetRequest, options?: AxiosRequestConfig) {
        return PasswordsApiFp(this.configuration).passwordResetsPost(message, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegistrationApi - axios parameter creator
 * @export
 */
export const RegistrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint will create a new organization and user. The user will not be able to log in until they have verified their email address. The email address must be unique and not used for any other basic auth login.
         * @summary Registers a new organization
         * @param {RegisterRegisterRequest} message Registration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPost: async (message: RegisterRegisterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('registerPost', 'message', message)
            const localVarPath = `/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistrationApi - functional programming interface
 * @export
 */
export const RegistrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistrationApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint will create a new organization and user. The user will not be able to log in until they have verified their email address. The email address must be unique and not used for any other basic auth login.
         * @summary Registers a new organization
         * @param {RegisterRegisterRequest} message Registration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerPost(message: RegisterRegisterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterRegisterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerPost(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegistrationApi - factory interface
 * @export
 */
export const RegistrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistrationApiFp(configuration)
    return {
        /**
         * This endpoint will create a new organization and user. The user will not be able to log in until they have verified their email address. The email address must be unique and not used for any other basic auth login.
         * @summary Registers a new organization
         * @param {RegisterRegisterRequest} message Registration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPost(message: RegisterRegisterRequest, options?: any): AxiosPromise<RegisterRegisterResponse> {
            return localVarFp.registerPost(message, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegistrationApi - object-oriented interface
 * @export
 * @class RegistrationApi
 * @extends {BaseAPI}
 */
export class RegistrationApi extends BaseAPI {
    /**
     * This endpoint will create a new organization and user. The user will not be able to log in until they have verified their email address. The email address must be unique and not used for any other basic auth login.
     * @summary Registers a new organization
     * @param {RegisterRegisterRequest} message Registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    public registerPost(message: RegisterRegisterRequest, options?: AxiosRequestConfig) {
        return RegistrationApiFp(this.configuration).registerPost(message, options).then((request) => request(this.axios, this.basePath));
    }
}


