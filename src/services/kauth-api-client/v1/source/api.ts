/* tslint:disable */
/* eslint-disable */
/**
 * KAuth
 * REST API for KAuth service
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddUserToTeamRequest
 */
export interface AddUserToTeamRequest {
    /**
     * 
     * @type {string}
     * @memberof AddUserToTeamRequest
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface AuthenticateAuthenticateRequest
 */
export interface AuthenticateAuthenticateRequest {
    /**
     * Password is the password for the user
     * @type {string}
     * @memberof AuthenticateAuthenticateRequest
     */
    'password': string;
    /**
     * Username is the name of the user to authenticate
     * @type {string}
     * @memberof AuthenticateAuthenticateRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface ClientconfigClientConfigResponse
 */
export interface ClientconfigClientConfigResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ClientconfigClientConfigResponse
     */
    'require-registration-access-code'?: boolean;
}
/**
 * 
 * @export
 * @interface EmailverificationsVerifyRequest
 */
export interface EmailverificationsVerifyRequest {
    /**
     * Token is an email verification token
     * @type {string}
     * @memberof EmailverificationsVerifyRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface EmailverificationsVerifyResponse
 */
export interface EmailverificationsVerifyResponse {
    /**
     * 
     * @type {string}
     * @memberof EmailverificationsVerifyResponse
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Code is an application-specific error code, expressed as a string value.
     * @type {string}
     * @memberof ErrorResponse
     */
    'code'?: string;
    /**
     * Detail is a human-readable explanation specific to this occurrence of the problem. Like title, this fieldâ€™s value can be localized.
     * @type {string}
     * @memberof ErrorResponse
     */
    'detail'?: string;
    /**
     * ID is a unique identifier for this particular occurrence of the problem.
     * @type {string}
     * @memberof ErrorResponse
     */
    'id'?: string;
    /**
     * 
     * @type {ErrorSource}
     * @memberof ErrorResponse
     */
    'source'?: ErrorSource;
    /**
     * Status is the HTTP status code applicable to this problem, expressed as a string value.
     * @type {string}
     * @memberof ErrorResponse
     */
    'status'?: string;
    /**
     * Title is a short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
     * @type {string}
     * @memberof ErrorResponse
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface ErrorSource
 */
export interface ErrorSource {
    /**
     * Parameter is a string indicating which URI query parameter caused the error
     * @type {string}
     * @memberof ErrorSource
     */
    'parameter'?: string;
    /**
     * Pointer is a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. \"/data\" for a primary data object, or \"/data/attributes/title\" for a specific attribute]
     * @type {string}
     * @memberof ErrorSource
     */
    'pointer'?: string;
}
/**
 * 
 * @export
 * @interface ErrorsResponse
 */
export interface ErrorsResponse {
    /**
     * 
     * @type {Array<ErrorResponse>}
     * @memberof ErrorsResponse
     */
    'errors'?: Array<ErrorResponse>;
}
/**
 * 
 * @export
 * @interface HealthAPIProtobufAny
 */
export interface HealthAPIProtobufAny {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof HealthAPIProtobufAny
     */
    '@type'?: string;
}
/**
 * 
 * @export
 * @interface HealthAPIRpcStatus
 */
export interface HealthAPIRpcStatus {
    /**
     * 
     * @type {number}
     * @memberof HealthAPIRpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {Array<HealthAPIProtobufAny>}
     * @memberof HealthAPIRpcStatus
     */
    'details'?: Array<HealthAPIProtobufAny>;
    /**
     * 
     * @type {string}
     * @memberof HealthAPIRpcStatus
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface HealthAPIV1CheckResponse
 */
export interface HealthAPIV1CheckResponse {
    /**
     * 
     * @type {HealthAPIV1ServingStatus}
     * @memberof HealthAPIV1CheckResponse
     */
    'status'?: HealthAPIV1ServingStatus;
    /**
     * 
     * @type {string}
     * @memberof HealthAPIV1CheckResponse
     */
    'version'?: string;
}
/**
 * - SERVING_STATUS_INVALID: Status is invalid/unknown  - SERVING_STATUS_SERVING: Service is serving  - SERVING_STATUS_NOT_SERVING: Service is not serving
 * @export
 * @enum {string}
 */

export enum HealthAPIV1ServingStatus {
    Invalid = 'SERVING_STATUS_INVALID',
    Serving = 'SERVING_STATUS_SERVING',
    NotServing = 'SERVING_STATUS_NOT_SERVING'
}

/**
 * 
 * @export
 * @interface IdentityProviderAPIProtobufAny
 */
export interface IdentityProviderAPIProtobufAny {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof IdentityProviderAPIProtobufAny
     */
    '@type'?: string;
}
/**
 * 
 * @export
 * @interface IdentityProviderAPIRpcStatus
 */
export interface IdentityProviderAPIRpcStatus {
    /**
     * 
     * @type {number}
     * @memberof IdentityProviderAPIRpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {Array<IdentityProviderAPIProtobufAny>}
     * @memberof IdentityProviderAPIRpcStatus
     */
    'details'?: Array<IdentityProviderAPIProtobufAny>;
    /**
     * 
     * @type {string}
     * @memberof IdentityProviderAPIRpcStatus
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface IdentityProviderAPIV1Config
 */
export interface IdentityProviderAPIV1Config {
    /**
     * 
     * @type {string}
     * @memberof IdentityProviderAPIV1Config
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityProviderAPIV1Config
     */
    'clientSecret'?: string;
    /**
     * 
     * @type {IdentityProviderAPIV1IDPType}
     * @memberof IdentityProviderAPIV1Config
     */
    'idpType'?: IdentityProviderAPIV1IDPType;
    /**
     * 
     * @type {string}
     * @memberof IdentityProviderAPIV1Config
     */
    'issuer'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityProviderAPIV1Config
     */
    'loginPath'?: string;
}
/**
 * 
 * @export
 * @interface IdentityProviderAPIV1GetResponse
 */
export interface IdentityProviderAPIV1GetResponse {
    /**
     * 
     * @type {IdentityProviderAPIV1IdentityProvider}
     * @memberof IdentityProviderAPIV1GetResponse
     */
    'identityProvider'?: IdentityProviderAPIV1IdentityProvider;
}
/**
 * - IDP_TYPE_INVALID: Invalid IdP  - IDP_TYPE_OIDC: Okta IdP
 * @export
 * @enum {string}
 */

export enum IdentityProviderAPIV1IDPType {
    Invalid = 'IDP_TYPE_INVALID',
    Oidc = 'IDP_TYPE_OIDC'
}

/**
 * 
 * @export
 * @interface IdentityProviderAPIV1IdentityProvider
 */
export interface IdentityProviderAPIV1IdentityProvider {
    /**
     * 
     * @type {Array<IdentityProviderAPIV1TeamAssignment>}
     * @memberof IdentityProviderAPIV1IdentityProvider
     */
    'assignments'?: Array<IdentityProviderAPIV1TeamAssignment>;
    /**
     * 
     * @type {IdentityProviderAPIV1Config}
     * @memberof IdentityProviderAPIV1IdentityProvider
     */
    'config'?: IdentityProviderAPIV1Config;
    /**
     * 
     * @type {IdentityProviderAPIV1Config}
     * @memberof IdentityProviderAPIV1IdentityProvider
     */
    'pendingConfig'?: IdentityProviderAPIV1Config;
}
/**
 * PromoteConfigRequest contains the request to promote an organization\'s pending idP config to active.
 * @export
 * @interface IdentityProviderAPIV1PromoteConfigRequest
 */
export interface IdentityProviderAPIV1PromoteConfigRequest {
    /**
     * 
     * @type {IdentityProviderAPIV1Config}
     * @memberof IdentityProviderAPIV1PromoteConfigRequest
     */
    'config'?: IdentityProviderAPIV1Config;
}
/**
 * PromoteConfigRequest contains the response from promote-config.
 * @export
 * @interface IdentityProviderAPIV1PromoteConfigResponse
 */
export interface IdentityProviderAPIV1PromoteConfigResponse {
    /**
     * 
     * @type {IdentityProviderAPIV1Config}
     * @memberof IdentityProviderAPIV1PromoteConfigResponse
     */
    'config'?: IdentityProviderAPIV1Config;
}
/**
 * 
 * @export
 * @interface IdentityProviderAPIV1TeamAssignment
 */
export interface IdentityProviderAPIV1TeamAssignment {
    /**
     * 
     * @type {string}
     * @memberof IdentityProviderAPIV1TeamAssignment
     */
    'group'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IdentityProviderAPIV1TeamAssignment
     */
    'teamIds'?: Array<string>;
}
/**
 * Request to update config. The given configuration will be stored as a pending configuration and a test login initiated.
 * @export
 * @interface IdentityProviderAPIV1UpdateConfigRequest
 */
export interface IdentityProviderAPIV1UpdateConfigRequest {
    /**
     * 
     * @type {IdentityProviderAPIV1Config}
     * @memberof IdentityProviderAPIV1UpdateConfigRequest
     */
    'config'?: IdentityProviderAPIV1Config;
}
/**
 * 
 * @export
 * @interface IdentityProviderAPIV1UpdateConfigResponse
 */
export interface IdentityProviderAPIV1UpdateConfigResponse {
    /**
     * 
     * @type {IdentityProviderAPIV1Config}
     * @memberof IdentityProviderAPIV1UpdateConfigResponse
     */
    'config'?: IdentityProviderAPIV1Config;
    /**
     * 
     * @type {string}
     * @memberof IdentityProviderAPIV1UpdateConfigResponse
     */
    'loginUrl'?: string;
}
/**
 * 
 * @export
 * @interface IdentityProviderAPIV1UpdateTeamAssignmentsRequest
 */
export interface IdentityProviderAPIV1UpdateTeamAssignmentsRequest {
    /**
     * 
     * @type {Array<IdentityProviderAPIV1TeamAssignment>}
     * @memberof IdentityProviderAPIV1UpdateTeamAssignmentsRequest
     */
    'assignments'?: Array<IdentityProviderAPIV1TeamAssignment>;
}
/**
 * 
 * @export
 * @interface IdentityProviderAPIV1UpdateTeamAssignmentsResponse
 */
export interface IdentityProviderAPIV1UpdateTeamAssignmentsResponse {
    /**
     * 
     * @type {Array<IdentityProviderAPIV1TeamAssignment>}
     * @memberof IdentityProviderAPIV1UpdateTeamAssignmentsResponse
     */
    'assignments'?: Array<IdentityProviderAPIV1TeamAssignment>;
}
/**
 * 
 * @export
 * @interface InviteAPIProtobufAny
 */
export interface InviteAPIProtobufAny {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof InviteAPIProtobufAny
     */
    '@type'?: string;
}
/**
 * 
 * @export
 * @interface InviteAPIRpcStatus
 */
export interface InviteAPIRpcStatus {
    /**
     * 
     * @type {number}
     * @memberof InviteAPIRpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {Array<InviteAPIProtobufAny>}
     * @memberof InviteAPIRpcStatus
     */
    'details'?: Array<InviteAPIProtobufAny>;
    /**
     * 
     * @type {string}
     * @memberof InviteAPIRpcStatus
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface InviteAPIV1Invite
 */
export interface InviteAPIV1Invite {
    /**
     * 
     * @type {string}
     * @memberof InviteAPIV1Invite
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteAPIV1Invite
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteAPIV1Invite
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteAPIV1Invite
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface InviteAPIV1InviteUserRequest
 */
export interface InviteAPIV1InviteUserRequest {
    /**
     * 
     * @type {string}
     * @memberof InviteAPIV1InviteUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteAPIV1InviteUserRequest
     */
    'fullName'?: string;
    /**
     * A list of team IDs to add the new user to.
     * @type {Array<string>}
     * @memberof InviteAPIV1InviteUserRequest
     */
    'teamIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface InviteAPIV1InviteUserResponse
 */
export interface InviteAPIV1InviteUserResponse {
    /**
     * 
     * @type {InviteAPIV1Invite}
     * @memberof InviteAPIV1InviteUserResponse
     */
    'invite'?: InviteAPIV1Invite;
}
/**
 * 
 * @export
 * @interface InvitesAcceptRequest
 */
export interface InvitesAcceptRequest {
    /**
     * Password is the user\'s new password
     * @type {string}
     * @memberof InvitesAcceptRequest
     */
    'password': string;
    /**
     * Token is an invitation token
     * @type {string}
     * @memberof InvitesAcceptRequest
     */
    'token': string;
}
/**
 * - SORT_ORDER_INVALID: Invalid default  - SORT_ORDER_ASCENDING: Ascending  - SORT_ORDER_DESCENDING: Descending
 * @export
 * @enum {string}
 */

export enum MeAPIOptionsSortOrder {
    Invalid = 'SORT_ORDER_INVALID',
    Ascending = 'SORT_ORDER_ASCENDING',
    Descending = 'SORT_ORDER_DESCENDING'
}

/**
 * 
 * @export
 * @interface MeAPIProtobufAny
 */
export interface MeAPIProtobufAny {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof MeAPIProtobufAny
     */
    '@type'?: string;
}
/**
 * 
 * @export
 * @interface MeAPIRetrieveOptionsFilter
 */
export interface MeAPIRetrieveOptionsFilter {
    /**
     * 
     * @type {string}
     * @memberof MeAPIRetrieveOptionsFilter
     */
    'q'?: string;
}
/**
 * 
 * @export
 * @interface MeAPIRetrieveOptionsPagination
 */
export interface MeAPIRetrieveOptionsPagination {
    /**
     * 
     * @type {number}
     * @memberof MeAPIRetrieveOptionsPagination
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof MeAPIRetrieveOptionsPagination
     */
    'offset'?: number;
}
/**
 * 
 * @export
 * @interface MeAPIRetrieveOptionsSort
 */
export interface MeAPIRetrieveOptionsSort {
    /**
     * 
     * @type {string}
     * @memberof MeAPIRetrieveOptionsSort
     */
    'sortBy'?: string;
    /**
     * 
     * @type {MeAPIOptionsSortOrder}
     * @memberof MeAPIRetrieveOptionsSort
     */
    'sortOrder'?: MeAPIOptionsSortOrder;
}
/**
 * 
 * @export
 * @interface MeAPIRpcStatus
 */
export interface MeAPIRpcStatus {
    /**
     * 
     * @type {number}
     * @memberof MeAPIRpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {Array<MeAPIProtobufAny>}
     * @memberof MeAPIRpcStatus
     */
    'details'?: Array<MeAPIProtobufAny>;
    /**
     * 
     * @type {string}
     * @memberof MeAPIRpcStatus
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface MeAPIV1Organization
 */
export interface MeAPIV1Organization {
    /**
     * 
     * @type {string}
     * @memberof MeAPIV1Organization
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MeAPIV1Organization
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface MeAPIV1Permission
 */
export interface MeAPIV1Permission {
    /**
     * 
     * @type {string}
     * @memberof MeAPIV1Permission
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof MeAPIV1Permission
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MeAPIV1Permission
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MeAPIV1Permission
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MeAPIV1Permission
     */
    'resource'?: string;
}
/**
 * 
 * @export
 * @interface MeAPIV1RetrieveTeamsResponse
 */
export interface MeAPIV1RetrieveTeamsResponse {
    /**
     * 
     * @type {Array<MeAPIV1Team>}
     * @memberof MeAPIV1RetrieveTeamsResponse
     */
    'teams'?: Array<MeAPIV1Team>;
}
/**
 * 
 * @export
 * @interface MeAPIV1Team
 */
export interface MeAPIV1Team {
    /**
     * 
     * @type {string}
     * @memberof MeAPIV1Team
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MeAPIV1Team
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface MeAPIV1User
 */
export interface MeAPIV1User {
    /**
     * 
     * @type {string}
     * @memberof MeAPIV1User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof MeAPIV1User
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MeAPIV1User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MeAPIV1User
     */
    'preferredName'?: string;
}
/**
 * 
 * @export
 * @interface MoveTeamRequest
 */
export interface MoveTeamRequest {
    /**
     * 
     * @type {string}
     * @memberof MoveTeamRequest
     */
    'parentTeamId'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationAPIProtobufAny
 */
export interface OrganizationAPIProtobufAny {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof OrganizationAPIProtobufAny
     */
    '@type'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationAPIRpcStatus
 */
export interface OrganizationAPIRpcStatus {
    /**
     * 
     * @type {number}
     * @memberof OrganizationAPIRpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {Array<OrganizationAPIProtobufAny>}
     * @memberof OrganizationAPIRpcStatus
     */
    'details'?: Array<OrganizationAPIProtobufAny>;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAPIRpcStatus
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface OrganizationAPIV1Settings
 */
export interface OrganizationAPIV1Settings {
    /**
     * 
     * @type {number}
     * @memberof OrganizationAPIV1Settings
     */
    'maxPasswordAttempts'?: number;
}
/**
 * 
 * @export
 * @interface OrganizationAPIV1UpdateOrganizationSettingsRequest
 */
export interface OrganizationAPIV1UpdateOrganizationSettingsRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationAPIV1UpdateOrganizationSettingsRequest
     */
    'organizationId'?: string;
    /**
     * 
     * @type {OrganizationAPIV1Settings}
     * @memberof OrganizationAPIV1UpdateOrganizationSettingsRequest
     */
    'settings'?: OrganizationAPIV1Settings;
}
/**
 * 
 * @export
 * @interface PasswordresetsRequestResetRequest
 */
export interface PasswordresetsRequestResetRequest {
    /**
     * Email is the email of the user requesting a password reset
     * @type {string}
     * @memberof PasswordresetsRequestResetRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface PasswordresetsResetRequest
 */
export interface PasswordresetsResetRequest {
    /**
     * Password is the user\'s new password
     * @type {string}
     * @memberof PasswordresetsResetRequest
     */
    'password': string;
    /**
     * Token is a password reset token
     * @type {string}
     * @memberof PasswordresetsResetRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface PasswordresetsResetResponse
 */
export interface PasswordresetsResetResponse {
    /**
     * 
     * @type {string}
     * @memberof PasswordresetsResetResponse
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface RegisterRegisterRequest
 */
export interface RegisterRegisterRequest {
    /**
     * Email is the email of the new user
     * @type {string}
     * @memberof RegisterRegisterRequest
     */
    'email': string;
    /**
     * FullName is the full name of the new user
     * @type {string}
     * @memberof RegisterRegisterRequest
     */
    'fullName': string;
    /**
     * Organization is the name of the new organization to create
     * @type {string}
     * @memberof RegisterRegisterRequest
     */
    'organization': string;
    /**
     * Password is the password of the new user
     * @type {string}
     * @memberof RegisterRegisterRequest
     */
    'password': string;
    /**
     * PreferredName is an optional preferred name of the new user
     * @type {string}
     * @memberof RegisterRegisterRequest
     */
    'preferredName'?: string;
    /**
     * Registration Code is the code required to register a new user
     * @type {string}
     * @memberof RegisterRegisterRequest
     */
    'registrationCode'?: string;
}
/**
 * 
 * @export
 * @interface RegisterRegisterResponse
 */
export interface RegisterRegisterResponse {
    /**
     * 
     * @type {string}
     * @memberof RegisterRegisterResponse
     */
    'organizationID'?: string;
}
/**
 * - SORT_ORDER_INVALID: Invalid default  - SORT_ORDER_ASCENDING: Ascending  - SORT_ORDER_DESCENDING: Descending
 * @export
 * @enum {string}
 */

export enum TeamAPIOptionsSortOrder {
    Invalid = 'SORT_ORDER_INVALID',
    Ascending = 'SORT_ORDER_ASCENDING',
    Descending = 'SORT_ORDER_DESCENDING'
}

/**
 * 
 * @export
 * @interface TeamAPIProtobufAny
 */
export interface TeamAPIProtobufAny {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof TeamAPIProtobufAny
     */
    '@type'?: string;
}
/**
 * 
 * @export
 * @interface TeamAPIRetrieveOptionsFilter
 */
export interface TeamAPIRetrieveOptionsFilter {
    /**
     * 
     * @type {string}
     * @memberof TeamAPIRetrieveOptionsFilter
     */
    'q'?: string;
}
/**
 * 
 * @export
 * @interface TeamAPIRetrieveOptionsPagination
 */
export interface TeamAPIRetrieveOptionsPagination {
    /**
     * 
     * @type {number}
     * @memberof TeamAPIRetrieveOptionsPagination
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof TeamAPIRetrieveOptionsPagination
     */
    'offset'?: number;
}
/**
 * 
 * @export
 * @interface TeamAPIRetrieveOptionsSort
 */
export interface TeamAPIRetrieveOptionsSort {
    /**
     * 
     * @type {string}
     * @memberof TeamAPIRetrieveOptionsSort
     */
    'sortBy'?: string;
    /**
     * 
     * @type {TeamAPIOptionsSortOrder}
     * @memberof TeamAPIRetrieveOptionsSort
     */
    'sortOrder'?: TeamAPIOptionsSortOrder;
}
/**
 * 
 * @export
 * @interface TeamAPIRpcStatus
 */
export interface TeamAPIRpcStatus {
    /**
     * 
     * @type {number}
     * @memberof TeamAPIRpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {Array<TeamAPIProtobufAny>}
     * @memberof TeamAPIRpcStatus
     */
    'details'?: Array<TeamAPIProtobufAny>;
    /**
     * 
     * @type {string}
     * @memberof TeamAPIRpcStatus
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface TeamAPIV1CreateTeamRequest
 */
export interface TeamAPIV1CreateTeamRequest {
    /**
     * 
     * @type {string}
     * @memberof TeamAPIV1CreateTeamRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamAPIV1CreateTeamRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TeamAPIV1CreateTeamResponse
 */
export interface TeamAPIV1CreateTeamResponse {
    /**
     * 
     * @type {TeamAPIV1Team}
     * @memberof TeamAPIV1CreateTeamResponse
     */
    'team'?: TeamAPIV1Team;
}
/**
 * 
 * @export
 * @interface TeamAPIV1MoveTeamResponse
 */
export interface TeamAPIV1MoveTeamResponse {
    /**
     * 
     * @type {TeamAPIV1Team}
     * @memberof TeamAPIV1MoveTeamResponse
     */
    'team'?: TeamAPIV1Team;
}
/**
 * 
 * @export
 * @interface TeamAPIV1RetrieveChildTeamsResponse
 */
export interface TeamAPIV1RetrieveChildTeamsResponse {
    /**
     * 
     * @type {number}
     * @memberof TeamAPIV1RetrieveChildTeamsResponse
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof TeamAPIV1RetrieveChildTeamsResponse
     */
    'parentTeamId'?: string;
    /**
     * 
     * @type {Array<TeamAPIV1Team>}
     * @memberof TeamAPIV1RetrieveChildTeamsResponse
     */
    'teams'?: Array<TeamAPIV1Team>;
}
/**
 * 
 * @export
 * @interface TeamAPIV1RetrieveTeamResponse
 */
export interface TeamAPIV1RetrieveTeamResponse {
    /**
     * 
     * @type {TeamAPIV1Team}
     * @memberof TeamAPIV1RetrieveTeamResponse
     */
    'team'?: TeamAPIV1Team;
}
/**
 * 
 * @export
 * @interface TeamAPIV1RetrieveTeamsResponse
 */
export interface TeamAPIV1RetrieveTeamsResponse {
    /**
     * 
     * @type {number}
     * @memberof TeamAPIV1RetrieveTeamsResponse
     */
    'count'?: number;
    /**
     * 
     * @type {Array<TeamAPIV1Team>}
     * @memberof TeamAPIV1RetrieveTeamsResponse
     */
    'teams'?: Array<TeamAPIV1Team>;
}
/**
 * 
 * @export
 * @interface TeamAPIV1RetrieveUsersForTeamResponse
 */
export interface TeamAPIV1RetrieveUsersForTeamResponse {
    /**
     * 
     * @type {number}
     * @memberof TeamAPIV1RetrieveUsersForTeamResponse
     */
    'count'?: number;
    /**
     * 
     * @type {Array<TeamAPIV1User>}
     * @memberof TeamAPIV1RetrieveUsersForTeamResponse
     */
    'users'?: Array<TeamAPIV1User>;
}
/**
 * 
 * @export
 * @interface TeamAPIV1Team
 */
export interface TeamAPIV1Team {
    /**
     * 
     * @type {string}
     * @memberof TeamAPIV1Team
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamAPIV1Team
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamAPIV1Team
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamAPIV1Team
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamAPIV1Team
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface TeamAPIV1UpdateTeamResponse
 */
export interface TeamAPIV1UpdateTeamResponse {
    /**
     * 
     * @type {TeamAPIV1Team}
     * @memberof TeamAPIV1UpdateTeamResponse
     */
    'team'?: TeamAPIV1Team;
}
/**
 * 
 * @export
 * @interface TeamAPIV1User
 */
export interface TeamAPIV1User {
    /**
     * 
     * @type {string}
     * @memberof TeamAPIV1User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamAPIV1User
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamAPIV1User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamAPIV1User
     */
    'preferredName'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTeamRequest
 */
export interface UpdateTeamRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UserAPIProtobufAny
 */
export interface UserAPIProtobufAny {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof UserAPIProtobufAny
     */
    '@type'?: string;
}
/**
 * 
 * @export
 * @interface UserAPIRetrieveOptionsFilter
 */
export interface UserAPIRetrieveOptionsFilter {
    /**
     * 
     * @type {string}
     * @memberof UserAPIRetrieveOptionsFilter
     */
    'q'?: string;
}
/**
 * 
 * @export
 * @interface UserAPIRetrieveOptionsPagination
 */
export interface UserAPIRetrieveOptionsPagination {
    /**
     * 
     * @type {number}
     * @memberof UserAPIRetrieveOptionsPagination
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserAPIRetrieveOptionsPagination
     */
    'offset'?: number;
}
/**
 * 
 * @export
 * @interface UserAPIRpcStatus
 */
export interface UserAPIRpcStatus {
    /**
     * 
     * @type {number}
     * @memberof UserAPIRpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {Array<UserAPIProtobufAny>}
     * @memberof UserAPIRpcStatus
     */
    'details'?: Array<UserAPIProtobufAny>;
    /**
     * 
     * @type {string}
     * @memberof UserAPIRpcStatus
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UserAPIV1RetrieveTeamsForUserResponse
 */
export interface UserAPIV1RetrieveTeamsForUserResponse {
    /**
     * 
     * @type {Array<UserAPIV1Team>}
     * @memberof UserAPIV1RetrieveTeamsForUserResponse
     */
    'teams'?: Array<UserAPIV1Team>;
}
/**
 * 
 * @export
 * @interface UserAPIV1RetrieveUserResponse
 */
export interface UserAPIV1RetrieveUserResponse {
    /**
     * 
     * @type {UserAPIV1User}
     * @memberof UserAPIV1RetrieveUserResponse
     */
    'user'?: UserAPIV1User;
}
/**
 * 
 * @export
 * @interface UserAPIV1RetrieveUsersResponse
 */
export interface UserAPIV1RetrieveUsersResponse {
    /**
     * 
     * @type {number}
     * @memberof UserAPIV1RetrieveUsersResponse
     */
    'count'?: number;
    /**
     * 
     * @type {Array<UserAPIV1User>}
     * @memberof UserAPIV1RetrieveUsersResponse
     */
    'users'?: Array<UserAPIV1User>;
}
/**
 * 
 * @export
 * @interface UserAPIV1Team
 */
export interface UserAPIV1Team {
    /**
     * 
     * @type {string}
     * @memberof UserAPIV1Team
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAPIV1Team
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAPIV1Team
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAPIV1Team
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAPIV1Team
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UserAPIV1User
 */
export interface UserAPIV1User {
    /**
     * 
     * @type {string}
     * @memberof UserAPIV1User
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAPIV1User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAPIV1User
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAPIV1User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAPIV1User
     */
    'preferredName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAPIV1User
     */
    'updatedAt'?: string;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will authenticate a user...
         * @summary Authenticates a user given a username and password
         * @param {AuthenticateAuthenticateRequest} message Authentication request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (message: AuthenticateAuthenticateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('authenticate', 'message', message)
            const localVarPath = `/api/v1/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the organization has an IdP setup, they will be redirected through that IdP, otherwise they will be redirected to the Konnect user login
         * @summary Redirects a user to the correct location for organization
         * @param {string} organizationId Organization ID
         * @param {string} [returnTo] Path to return to after authentication has completed
         * @param {string} [test] Configuration test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateOrg: async (organizationId: string, returnTo?: string, test?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('authenticateOrg', 'organizationId', organizationId)
            const localVarPath = `/api/v1/authenticate/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnTo !== undefined) {
                localVarQueryParameter['returnTo'] = returnTo;
            }

            if (test !== undefined) {
                localVarQueryParameter['test'] = test;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh will set a new access and refresh token if the user is still valid.
         * @summary Refreshes a user if a valid refresh token is provided
         * @param {object} message refresh request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh: async (message: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('refresh', 'message', message)
            const localVarPath = `/api/v1/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * This will authenticate a user...
         * @summary Authenticates a user given a username and password
         * @param {AuthenticateAuthenticateRequest} message Authentication request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(message: AuthenticateAuthenticateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If the organization has an IdP setup, they will be redirected through that IdP, otherwise they will be redirected to the Konnect user login
         * @summary Redirects a user to the correct location for organization
         * @param {string} organizationId Organization ID
         * @param {string} [returnTo] Path to return to after authentication has completed
         * @param {string} [test] Configuration test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateOrg(organizationId: string, returnTo?: string, test?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateOrg(organizationId, returnTo, test, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh will set a new access and refresh token if the user is still valid.
         * @summary Refreshes a user if a valid refresh token is provided
         * @param {object} message refresh request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refresh(message: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * This will authenticate a user...
         * @summary Authenticates a user given a username and password
         * @param {AuthenticateAuthenticateRequest} message Authentication request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(message: AuthenticateAuthenticateRequest, options?: any): AxiosPromise<object> {
            return localVarFp.authenticate(message, options).then((request) => request(axios, basePath));
        },
        /**
         * If the organization has an IdP setup, they will be redirected through that IdP, otherwise they will be redirected to the Konnect user login
         * @summary Redirects a user to the correct location for organization
         * @param {string} organizationId Organization ID
         * @param {string} [returnTo] Path to return to after authentication has completed
         * @param {string} [test] Configuration test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateOrg(organizationId: string, returnTo?: string, test?: string, options?: any): AxiosPromise<void> {
            return localVarFp.authenticateOrg(organizationId, returnTo, test, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh will set a new access and refresh token if the user is still valid.
         * @summary Refreshes a user if a valid refresh token is provided
         * @param {object} message refresh request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(message: object, options?: any): AxiosPromise<object> {
            return localVarFp.refresh(message, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * This will authenticate a user...
     * @summary Authenticates a user given a username and password
     * @param {AuthenticateAuthenticateRequest} message Authentication request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticate(message: AuthenticateAuthenticateRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticate(message, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If the organization has an IdP setup, they will be redirected through that IdP, otherwise they will be redirected to the Konnect user login
     * @summary Redirects a user to the correct location for organization
     * @param {string} organizationId Organization ID
     * @param {string} [returnTo] Path to return to after authentication has completed
     * @param {string} [test] Configuration test mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticateOrg(organizationId: string, returnTo?: string, test?: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticateOrg(organizationId, returnTo, test, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh will set a new access and refresh token if the user is still valid.
     * @summary Refreshes a user if a valid refresh token is provided
     * @param {object} message refresh request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public refresh(message: object, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refresh(message, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientConfigApi - axios parameter creator
 * @export
 */
export const ClientConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * this endpoint will check if the `require-registration-access-code` has been set in the config
         * @summary returns a json with wether the require-registration-access-code (bool) has been set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/client-config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientConfigApi - functional programming interface
 * @export
 */
export const ClientConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * this endpoint will check if the `require-registration-access-code` has been set in the config
         * @summary returns a json with wether the require-registration-access-code (bool) has been set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientconfigClientConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientConfigApi - factory interface
 * @export
 */
export const ClientConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientConfigApiFp(configuration)
    return {
        /**
         * this endpoint will check if the `require-registration-access-code` has been set in the config
         * @summary returns a json with wether the require-registration-access-code (bool) has been set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientConfig(options?: any): AxiosPromise<ClientconfigClientConfigResponse> {
            return localVarFp.clientConfig(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientConfigApi - object-oriented interface
 * @export
 * @class ClientConfigApi
 * @extends {BaseAPI}
 */
export class ClientConfigApi extends BaseAPI {
    /**
     * this endpoint will check if the `require-registration-access-code` has been set in the config
     * @summary returns a json with wether the require-registration-access-code (bool) has been set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientConfigApi
     */
    public clientConfig(options?: AxiosRequestConfig) {
        return ClientConfigApiFp(this.configuration).clientConfig(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EmailVerificationApi - axios parameter creator
 * @export
 */
export const EmailVerificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint verifies a user\'s email given an email verification token.
         * @summary Verifies a user\'s email address
         * @param {EmailverificationsVerifyRequest} message Verify email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail: async (message: EmailverificationsVerifyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('verifyEmail', 'message', message)
            const localVarPath = `/api/v1/email-verifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailVerificationApi - functional programming interface
 * @export
 */
export const EmailVerificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmailVerificationApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint verifies a user\'s email given an email verification token.
         * @summary Verifies a user\'s email address
         * @param {EmailverificationsVerifyRequest} message Verify email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmail(message: EmailverificationsVerifyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailverificationsVerifyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmail(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EmailVerificationApi - factory interface
 * @export
 */
export const EmailVerificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmailVerificationApiFp(configuration)
    return {
        /**
         * This endpoint verifies a user\'s email given an email verification token.
         * @summary Verifies a user\'s email address
         * @param {EmailverificationsVerifyRequest} message Verify email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(message: EmailverificationsVerifyRequest, options?: any): AxiosPromise<EmailverificationsVerifyResponse> {
            return localVarFp.verifyEmail(message, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmailVerificationApi - object-oriented interface
 * @export
 * @class EmailVerificationApi
 * @extends {BaseAPI}
 */
export class EmailVerificationApi extends BaseAPI {
    /**
     * This endpoint verifies a user\'s email given an email verification token.
     * @summary Verifies a user\'s email address
     * @param {EmailverificationsVerifyRequest} message Verify email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailVerificationApi
     */
    public verifyEmail(message: EmailverificationsVerifyRequest, options?: AxiosRequestConfig) {
        return EmailVerificationApiFp(this.configuration).verifyEmail(message, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthAPIApi - axios parameter creator
 * @export
 */
export const HealthAPIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check returns the status of the service
         * @param {string} [service] service to check, can be blank.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthAPICheck: async (service?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (service !== undefined) {
                localVarQueryParameter['service'] = service;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthAPIApi - functional programming interface
 * @export
 */
export const HealthAPIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthAPIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check returns the status of the service
         * @param {string} [service] service to check, can be blank.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthAPICheck(service?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthAPIV1CheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthAPICheck(service, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthAPIApi - factory interface
 * @export
 */
export const HealthAPIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthAPIApiFp(configuration)
    return {
        /**
         * 
         * @summary Check returns the status of the service
         * @param {string} [service] service to check, can be blank.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthAPICheck(service?: string, options?: any): AxiosPromise<HealthAPIV1CheckResponse> {
            return localVarFp.healthAPICheck(service, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthAPIApi - object-oriented interface
 * @export
 * @class HealthAPIApi
 * @extends {BaseAPI}
 */
export class HealthAPIApi extends BaseAPI {
    /**
     * 
     * @summary Check returns the status of the service
     * @param {string} [service] service to check, can be blank.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthAPIApi
     */
    public healthAPICheck(service?: string, options?: AxiosRequestConfig) {
        return HealthAPIApiFp(this.configuration).healthAPICheck(service, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdentityProviderAPIApi - axios parameter creator
 * @export
 */
export const IdentityProviderAPIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the IdP configured for an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityProviderAPIGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/identity-provider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Promote \"pending\" third-party IdP config to current
         * @param {IdentityProviderAPIV1PromoteConfigRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityProviderAPIPromoteConfig: async (body: IdentityProviderAPIV1PromoteConfigRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('identityProviderAPIPromoteConfig', 'body', body)
            const localVarPath = `/api/v1/identity-provider/promote-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a third party IdP config for an organization
         * @param {IdentityProviderAPIV1UpdateConfigRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityProviderAPIUpdateConfig: async (body: IdentityProviderAPIV1UpdateConfigRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('identityProviderAPIUpdateConfig', 'body', body)
            const localVarPath = `/api/v1/identity-provider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the group to team assignments for the IdP
         * @param {IdentityProviderAPIV1UpdateTeamAssignmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityProviderAPIUpdateTeamAssignments: async (body: IdentityProviderAPIV1UpdateTeamAssignmentsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('identityProviderAPIUpdateTeamAssignments', 'body', body)
            const localVarPath = `/api/v1/identity-provider/team-assignments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityProviderAPIApi - functional programming interface
 * @export
 */
export const IdentityProviderAPIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityProviderAPIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets the IdP configured for an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityProviderAPIGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProviderAPIV1GetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityProviderAPIGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Promote \"pending\" third-party IdP config to current
         * @param {IdentityProviderAPIV1PromoteConfigRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityProviderAPIPromoteConfig(body: IdentityProviderAPIV1PromoteConfigRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProviderAPIV1PromoteConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityProviderAPIPromoteConfig(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates a third party IdP config for an organization
         * @param {IdentityProviderAPIV1UpdateConfigRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityProviderAPIUpdateConfig(body: IdentityProviderAPIV1UpdateConfigRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProviderAPIV1UpdateConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityProviderAPIUpdateConfig(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the group to team assignments for the IdP
         * @param {IdentityProviderAPIV1UpdateTeamAssignmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityProviderAPIUpdateTeamAssignments(body: IdentityProviderAPIV1UpdateTeamAssignmentsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProviderAPIV1UpdateTeamAssignmentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityProviderAPIUpdateTeamAssignments(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdentityProviderAPIApi - factory interface
 * @export
 */
export const IdentityProviderAPIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityProviderAPIApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets the IdP configured for an organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityProviderAPIGet(options?: any): AxiosPromise<IdentityProviderAPIV1GetResponse> {
            return localVarFp.identityProviderAPIGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Promote \"pending\" third-party IdP config to current
         * @param {IdentityProviderAPIV1PromoteConfigRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityProviderAPIPromoteConfig(body: IdentityProviderAPIV1PromoteConfigRequest, options?: any): AxiosPromise<IdentityProviderAPIV1PromoteConfigResponse> {
            return localVarFp.identityProviderAPIPromoteConfig(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a third party IdP config for an organization
         * @param {IdentityProviderAPIV1UpdateConfigRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityProviderAPIUpdateConfig(body: IdentityProviderAPIV1UpdateConfigRequest, options?: any): AxiosPromise<IdentityProviderAPIV1UpdateConfigResponse> {
            return localVarFp.identityProviderAPIUpdateConfig(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the group to team assignments for the IdP
         * @param {IdentityProviderAPIV1UpdateTeamAssignmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityProviderAPIUpdateTeamAssignments(body: IdentityProviderAPIV1UpdateTeamAssignmentsRequest, options?: any): AxiosPromise<IdentityProviderAPIV1UpdateTeamAssignmentsResponse> {
            return localVarFp.identityProviderAPIUpdateTeamAssignments(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdentityProviderAPIApi - object-oriented interface
 * @export
 * @class IdentityProviderAPIApi
 * @extends {BaseAPI}
 */
export class IdentityProviderAPIApi extends BaseAPI {
    /**
     * 
     * @summary Gets the IdP configured for an organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProviderAPIApi
     */
    public identityProviderAPIGet(options?: AxiosRequestConfig) {
        return IdentityProviderAPIApiFp(this.configuration).identityProviderAPIGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Promote \"pending\" third-party IdP config to current
     * @param {IdentityProviderAPIV1PromoteConfigRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProviderAPIApi
     */
    public identityProviderAPIPromoteConfig(body: IdentityProviderAPIV1PromoteConfigRequest, options?: AxiosRequestConfig) {
        return IdentityProviderAPIApiFp(this.configuration).identityProviderAPIPromoteConfig(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a third party IdP config for an organization
     * @param {IdentityProviderAPIV1UpdateConfigRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProviderAPIApi
     */
    public identityProviderAPIUpdateConfig(body: IdentityProviderAPIV1UpdateConfigRequest, options?: AxiosRequestConfig) {
        return IdentityProviderAPIApiFp(this.configuration).identityProviderAPIUpdateConfig(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the group to team assignments for the IdP
     * @param {IdentityProviderAPIV1UpdateTeamAssignmentsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityProviderAPIApi
     */
    public identityProviderAPIUpdateTeamAssignments(body: IdentityProviderAPIV1UpdateTeamAssignmentsRequest, options?: AxiosRequestConfig) {
        return IdentityProviderAPIApiFp(this.configuration).identityProviderAPIUpdateTeamAssignments(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InviteAPIApi - axios parameter creator
 * @export
 */
export const InviteAPIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary InviteUser adds a user to the organization and sends an invite email to the new user.
         * @param {InviteAPIV1InviteUserRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteAPIInviteUser: async (body: InviteAPIV1InviteUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('inviteAPIInviteUser', 'body', body)
            const localVarPath = `/api/v1/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InviteAPIApi - functional programming interface
 * @export
 */
export const InviteAPIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InviteAPIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary InviteUser adds a user to the organization and sends an invite email to the new user.
         * @param {InviteAPIV1InviteUserRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteAPIInviteUser(body: InviteAPIV1InviteUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteAPIV1InviteUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteAPIInviteUser(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InviteAPIApi - factory interface
 * @export
 */
export const InviteAPIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InviteAPIApiFp(configuration)
    return {
        /**
         * 
         * @summary InviteUser adds a user to the organization and sends an invite email to the new user.
         * @param {InviteAPIV1InviteUserRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteAPIInviteUser(body: InviteAPIV1InviteUserRequest, options?: any): AxiosPromise<InviteAPIV1InviteUserResponse> {
            return localVarFp.inviteAPIInviteUser(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InviteAPIApi - object-oriented interface
 * @export
 * @class InviteAPIApi
 * @extends {BaseAPI}
 */
export class InviteAPIApi extends BaseAPI {
    /**
     * 
     * @summary InviteUser adds a user to the organization and sends an invite email to the new user.
     * @param {InviteAPIV1InviteUserRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteAPIApi
     */
    public inviteAPIInviteUser(body: InviteAPIV1InviteUserRequest, options?: AxiosRequestConfig) {
        return InviteAPIApiFp(this.configuration).inviteAPIInviteUser(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvitesApi - axios parameter creator
 * @export
 */
export const InvitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint accepts an invitation and sets the user\'s initial password. It will also mark the user\'s email address as verified.
         * @summary Accepts an invitation
         * @param {InvitesAcceptRequest} message Verify email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite: async (message: InvitesAcceptRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('acceptInvite', 'message', message)
            const localVarPath = `/api/v1/accept-invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitesApi - functional programming interface
 * @export
 */
export const InvitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitesApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint accepts an invitation and sets the user\'s initial password. It will also mark the user\'s email address as verified.
         * @summary Accepts an invitation
         * @param {InvitesAcceptRequest} message Verify email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvite(message: InvitesAcceptRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvite(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvitesApi - factory interface
 * @export
 */
export const InvitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitesApiFp(configuration)
    return {
        /**
         * This endpoint accepts an invitation and sets the user\'s initial password. It will also mark the user\'s email address as verified.
         * @summary Accepts an invitation
         * @param {InvitesAcceptRequest} message Verify email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(message: InvitesAcceptRequest, options?: any): AxiosPromise<object> {
            return localVarFp.acceptInvite(message, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitesApi - object-oriented interface
 * @export
 * @class InvitesApi
 * @extends {BaseAPI}
 */
export class InvitesApi extends BaseAPI {
    /**
     * This endpoint accepts an invitation and sets the user\'s initial password. It will also mark the user\'s email address as verified.
     * @summary Accepts an invitation
     * @param {InvitesAcceptRequest} message Verify email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public acceptInvite(message: InvitesAcceptRequest, options?: AxiosRequestConfig) {
        return InvitesApiFp(this.configuration).acceptInvite(message, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LogoutApi - axios parameter creator
 * @export
 */
export const LogoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Logout will clear the auth cookies
         * @summary logout by clearing the auth cookies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogoutApi - functional programming interface
 * @export
 */
export const LogoutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogoutApiAxiosParamCreator(configuration)
    return {
        /**
         * Logout will clear the auth cookies
         * @summary logout by clearing the auth cookies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LogoutApi - factory interface
 * @export
 */
export const LogoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogoutApiFp(configuration)
    return {
        /**
         * Logout will clear the auth cookies
         * @summary logout by clearing the auth cookies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<object> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogoutApi - object-oriented interface
 * @export
 * @class LogoutApi
 * @extends {BaseAPI}
 */
export class LogoutApi extends BaseAPI {
    /**
     * Logout will clear the auth cookies
     * @summary logout by clearing the auth cookies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogoutApi
     */
    public logout(options?: AxiosRequestConfig) {
        return LogoutApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MeAPIApi - axios parameter creator
 * @export
 */
export const MeAPIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary RetrieveTeams retrieves the team the current user belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meAPIRetrieveTeams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/me/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeAPIApi - functional programming interface
 * @export
 */
export const MeAPIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeAPIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary RetrieveTeams retrieves the team the current user belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meAPIRetrieveTeams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeAPIV1RetrieveTeamsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meAPIRetrieveTeams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MeAPIApi - factory interface
 * @export
 */
export const MeAPIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeAPIApiFp(configuration)
    return {
        /**
         * 
         * @summary RetrieveTeams retrieves the team the current user belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meAPIRetrieveTeams(options?: any): AxiosPromise<MeAPIV1RetrieveTeamsResponse> {
            return localVarFp.meAPIRetrieveTeams(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeAPIApi - object-oriented interface
 * @export
 * @class MeAPIApi
 * @extends {BaseAPI}
 */
export class MeAPIApi extends BaseAPI {
    /**
     * 
     * @summary RetrieveTeams retrieves the team the current user belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeAPIApi
     */
    public meAPIRetrieveTeams(options?: AxiosRequestConfig) {
        return MeAPIApiFp(this.configuration).meAPIRetrieveTeams(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationAPIApi - axios parameter creator
 * @export
 */
export const OrganizationAPIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Updates an existing organization
         * @param {OrganizationAPIV1UpdateOrganizationSettingsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAPIUpdateOrganizationSettings: async (body: OrganizationAPIV1UpdateOrganizationSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('organizationAPIUpdateOrganizationSettings', 'body', body)
            const localVarPath = `/api/v1/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationAPIApi - functional programming interface
 * @export
 */
export const OrganizationAPIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationAPIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Updates an existing organization
         * @param {OrganizationAPIV1UpdateOrganizationSettingsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAPIUpdateOrganizationSettings(body: OrganizationAPIV1UpdateOrganizationSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAPIUpdateOrganizationSettings(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationAPIApi - factory interface
 * @export
 */
export const OrganizationAPIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationAPIApiFp(configuration)
    return {
        /**
         * 
         * @summary Updates an existing organization
         * @param {OrganizationAPIV1UpdateOrganizationSettingsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAPIUpdateOrganizationSettings(body: OrganizationAPIV1UpdateOrganizationSettingsRequest, options?: any): AxiosPromise<object> {
            return localVarFp.organizationAPIUpdateOrganizationSettings(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationAPIApi - object-oriented interface
 * @export
 * @class OrganizationAPIApi
 * @extends {BaseAPI}
 */
export class OrganizationAPIApi extends BaseAPI {
    /**
     * 
     * @summary Updates an existing organization
     * @param {OrganizationAPIV1UpdateOrganizationSettingsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationAPIApi
     */
    public organizationAPIUpdateOrganizationSettings(body: OrganizationAPIV1UpdateOrganizationSettingsRequest, options?: AxiosRequestConfig) {
        return OrganizationAPIApiFp(this.configuration).organizationAPIUpdateOrganizationSettings(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PasswordsApi - axios parameter creator
 * @export
 */
export const PasswordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint creates a reset request entry and sends the user an email with a link to reset their password. It will return success if the email address is not found.
         * @summary Creates a password reset request
         * @param {PasswordresetsRequestResetRequest} message Request Reset Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordReset: async (message: PasswordresetsRequestResetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('requestPasswordReset', 'message', message)
            const localVarPath = `/api/v1/password-resets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates a user\'s password given a reset token.
         * @summary Resets a user\'s password
         * @param {PasswordresetsResetRequest} message Reset Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (message: PasswordresetsResetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('resetPassword', 'message', message)
            const localVarPath = `/api/v1/password-resets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordsApi - functional programming interface
 * @export
 */
export const PasswordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint creates a reset request entry and sends the user an email with a link to reset their password. It will return success if the email address is not found.
         * @summary Creates a password reset request
         * @param {PasswordresetsRequestResetRequest} message Request Reset Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestPasswordReset(message: PasswordresetsRequestResetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestPasswordReset(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint updates a user\'s password given a reset token.
         * @summary Resets a user\'s password
         * @param {PasswordresetsResetRequest} message Reset Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(message: PasswordresetsResetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordresetsResetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PasswordsApi - factory interface
 * @export
 */
export const PasswordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordsApiFp(configuration)
    return {
        /**
         * This endpoint creates a reset request entry and sends the user an email with a link to reset their password. It will return success if the email address is not found.
         * @summary Creates a password reset request
         * @param {PasswordresetsRequestResetRequest} message Request Reset Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordReset(message: PasswordresetsRequestResetRequest, options?: any): AxiosPromise<object> {
            return localVarFp.requestPasswordReset(message, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint updates a user\'s password given a reset token.
         * @summary Resets a user\'s password
         * @param {PasswordresetsResetRequest} message Reset Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(message: PasswordresetsResetRequest, options?: any): AxiosPromise<PasswordresetsResetResponse> {
            return localVarFp.resetPassword(message, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PasswordsApi - object-oriented interface
 * @export
 * @class PasswordsApi
 * @extends {BaseAPI}
 */
export class PasswordsApi extends BaseAPI {
    /**
     * This endpoint creates a reset request entry and sends the user an email with a link to reset their password. It will return success if the email address is not found.
     * @summary Creates a password reset request
     * @param {PasswordresetsRequestResetRequest} message Request Reset Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordsApi
     */
    public requestPasswordReset(message: PasswordresetsRequestResetRequest, options?: AxiosRequestConfig) {
        return PasswordsApiFp(this.configuration).requestPasswordReset(message, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint updates a user\'s password given a reset token.
     * @summary Resets a user\'s password
     * @param {PasswordresetsResetRequest} message Reset Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordsApi
     */
    public resetPassword(message: PasswordresetsResetRequest, options?: AxiosRequestConfig) {
        return PasswordsApiFp(this.configuration).resetPassword(message, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegistrationApi - axios parameter creator
 * @export
 */
export const RegistrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint will create a new organization and user. The user will not be able to log in until they have verified their email address. The email address must be unique and not used for any other basic auth login.
         * @summary Registers a new organization
         * @param {RegisterRegisterRequest} message Registration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (message: RegisterRegisterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('register', 'message', message)
            const localVarPath = `/api/v1/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistrationApi - functional programming interface
 * @export
 */
export const RegistrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistrationApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint will create a new organization and user. The user will not be able to log in until they have verified their email address. The email address must be unique and not used for any other basic auth login.
         * @summary Registers a new organization
         * @param {RegisterRegisterRequest} message Registration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(message: RegisterRegisterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterRegisterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegistrationApi - factory interface
 * @export
 */
export const RegistrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistrationApiFp(configuration)
    return {
        /**
         * This endpoint will create a new organization and user. The user will not be able to log in until they have verified their email address. The email address must be unique and not used for any other basic auth login.
         * @summary Registers a new organization
         * @param {RegisterRegisterRequest} message Registration request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(message: RegisterRegisterRequest, options?: any): AxiosPromise<RegisterRegisterResponse> {
            return localVarFp.register(message, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegistrationApi - object-oriented interface
 * @export
 * @class RegistrationApi
 * @extends {BaseAPI}
 */
export class RegistrationApi extends BaseAPI {
    /**
     * This endpoint will create a new organization and user. The user will not be able to log in until they have verified their email address. The email address must be unique and not used for any other basic auth login.
     * @summary Registers a new organization
     * @param {RegisterRegisterRequest} message Registration request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    public register(message: RegisterRegisterRequest, options?: AxiosRequestConfig) {
        return RegistrationApiFp(this.configuration).register(message, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamAPIApi - axios parameter creator
 * @export
 */
export const TeamAPIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a user to a team
         * @param {string} teamId ID of the team under which the user should be added
         * @param {AddUserToTeamRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIAddUserToTeam: async (teamId: string, body: AddUserToTeamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamAPIAddUserToTeam', 'teamId', teamId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('teamAPIAddUserToTeam', 'body', body)
            const localVarPath = `/api/v1/teams/{teamId}/users`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a team
         * @param {TeamAPIV1CreateTeamRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPICreateTeam: async (body: TeamAPIV1CreateTeamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('teamAPICreateTeam', 'body', body)
            const localVarPath = `/api/v1/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Moves a team to be a child of an existing team
         * @param {string} teamId ID of the team to be moved
         * @param {MoveTeamRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIMoveTeam: async (teamId: string, body: MoveTeamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamAPIMoveTeam', 'teamId', teamId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('teamAPIMoveTeam', 'body', body)
            const localVarPath = `/api/v1/teams/{teamId}:move`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes a team and all its sub-teams
         * @param {string} teamId ID of the team that will be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIRemoveTeam: async (teamId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamAPIRemoveTeam', 'teamId', teamId)
            const localVarPath = `/api/v1/teams/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes a user from a team
         * @param {string} teamId ID of the team from which the user should be removed
         * @param {string} [userId] ID of the user to remove from the team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIRemoveUserFromTeam: async (teamId: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamAPIRemoveUserFromTeam', 'teamId', teamId)
            const localVarPath = `/api/v1/teams/{teamId}/users`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets child teams
         * @param {string} teamId ID of the team from which permissions should be retrieved
         * @param {string} [optionsFilterQ] The query to filter on.
         * @param {number} [optionsPaginationOffset] Pagination offset.
         * @param {number} [optionsPaginationLimit] Result limit.
         * @param {'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING'} [optionsSortSortOrder] result order.   - SORT_ORDER_INVALID: Invalid default  - SORT_ORDER_ASCENDING: Ascending  - SORT_ORDER_DESCENDING: Descending
         * @param {string} [optionsSortSortBy] sort field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIRetrieveChildTeams: async (teamId: string, optionsFilterQ?: string, optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsSortSortOrder?: 'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING', optionsSortSortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamAPIRetrieveChildTeams', 'teamId', teamId)
            const localVarPath = `/api/v1/teams/{teamId}/teams`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (optionsFilterQ !== undefined) {
                localVarQueryParameter['options.filter.q'] = optionsFilterQ;
            }

            if (optionsPaginationOffset !== undefined) {
                localVarQueryParameter['options.pagination.offset'] = optionsPaginationOffset;
            }

            if (optionsPaginationLimit !== undefined) {
                localVarQueryParameter['options.pagination.limit'] = optionsPaginationLimit;
            }

            if (optionsSortSortOrder !== undefined) {
                localVarQueryParameter['options.sort.sortOrder'] = optionsSortSortOrder;
            }

            if (optionsSortSortBy !== undefined) {
                localVarQueryParameter['options.sort.sortBy'] = optionsSortSortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a team
         * @param {string} teamId ID of the team to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIRetrieveTeam: async (teamId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamAPIRetrieveTeam', 'teamId', teamId)
            const localVarPath = `/api/v1/teams/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets teams
         * @param {string} [optionsFilterQ] The query to filter on.
         * @param {number} [optionsPaginationOffset] Pagination offset.
         * @param {number} [optionsPaginationLimit] Result limit.
         * @param {'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING'} [optionsSortSortOrder] result order.   - SORT_ORDER_INVALID: Invalid default  - SORT_ORDER_ASCENDING: Ascending  - SORT_ORDER_DESCENDING: Descending
         * @param {string} [optionsSortSortBy] sort field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIRetrieveTeams: async (optionsFilterQ?: string, optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsSortSortOrder?: 'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING', optionsSortSortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (optionsFilterQ !== undefined) {
                localVarQueryParameter['options.filter.q'] = optionsFilterQ;
            }

            if (optionsPaginationOffset !== undefined) {
                localVarQueryParameter['options.pagination.offset'] = optionsPaginationOffset;
            }

            if (optionsPaginationLimit !== undefined) {
                localVarQueryParameter['options.pagination.limit'] = optionsPaginationLimit;
            }

            if (optionsSortSortOrder !== undefined) {
                localVarQueryParameter['options.sort.sortOrder'] = optionsSortSortOrder;
            }

            if (optionsSortSortBy !== undefined) {
                localVarQueryParameter['options.sort.sortBy'] = optionsSortSortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the Users in a team
         * @param {string} teamId team id of team whose users will be retrieved
         * @param {string} [optionsFilterQ] The query to filter on.
         * @param {number} [optionsPaginationOffset] Pagination offset.
         * @param {number} [optionsPaginationLimit] Result limit.
         * @param {'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING'} [optionsSortSortOrder] result order.   - SORT_ORDER_INVALID: Invalid default  - SORT_ORDER_ASCENDING: Ascending  - SORT_ORDER_DESCENDING: Descending
         * @param {string} [optionsSortSortBy] sort field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIRetrieveUsersForTeam: async (teamId: string, optionsFilterQ?: string, optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsSortSortOrder?: 'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING', optionsSortSortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamAPIRetrieveUsersForTeam', 'teamId', teamId)
            const localVarPath = `/api/v1/teams/{teamId}/users`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (optionsFilterQ !== undefined) {
                localVarQueryParameter['options.filter.q'] = optionsFilterQ;
            }

            if (optionsPaginationOffset !== undefined) {
                localVarQueryParameter['options.pagination.offset'] = optionsPaginationOffset;
            }

            if (optionsPaginationLimit !== undefined) {
                localVarQueryParameter['options.pagination.limit'] = optionsPaginationLimit;
            }

            if (optionsSortSortOrder !== undefined) {
                localVarQueryParameter['options.sort.sortOrder'] = optionsSortSortOrder;
            }

            if (optionsSortSortBy !== undefined) {
                localVarQueryParameter['options.sort.sortBy'] = optionsSortSortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a team
         * @param {string} teamId ID of the team to be updated
         * @param {UpdateTeamRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIUpdateTeam: async (teamId: string, body: UpdateTeamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamAPIUpdateTeam', 'teamId', teamId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('teamAPIUpdateTeam', 'body', body)
            const localVarPath = `/api/v1/teams/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamAPIApi - functional programming interface
 * @export
 */
export const TeamAPIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamAPIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds a user to a team
         * @param {string} teamId ID of the team under which the user should be added
         * @param {AddUserToTeamRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamAPIAddUserToTeam(teamId: string, body: AddUserToTeamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamAPIAddUserToTeam(teamId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a team
         * @param {TeamAPIV1CreateTeamRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamAPICreateTeam(body: TeamAPIV1CreateTeamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamAPIV1CreateTeamResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamAPICreateTeam(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Moves a team to be a child of an existing team
         * @param {string} teamId ID of the team to be moved
         * @param {MoveTeamRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamAPIMoveTeam(teamId: string, body: MoveTeamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamAPIV1MoveTeamResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamAPIMoveTeam(teamId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Removes a team and all its sub-teams
         * @param {string} teamId ID of the team that will be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamAPIRemoveTeam(teamId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamAPIRemoveTeam(teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Removes a user from a team
         * @param {string} teamId ID of the team from which the user should be removed
         * @param {string} [userId] ID of the user to remove from the team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamAPIRemoveUserFromTeam(teamId: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamAPIRemoveUserFromTeam(teamId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets child teams
         * @param {string} teamId ID of the team from which permissions should be retrieved
         * @param {string} [optionsFilterQ] The query to filter on.
         * @param {number} [optionsPaginationOffset] Pagination offset.
         * @param {number} [optionsPaginationLimit] Result limit.
         * @param {'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING'} [optionsSortSortOrder] result order.   - SORT_ORDER_INVALID: Invalid default  - SORT_ORDER_ASCENDING: Ascending  - SORT_ORDER_DESCENDING: Descending
         * @param {string} [optionsSortSortBy] sort field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamAPIRetrieveChildTeams(teamId: string, optionsFilterQ?: string, optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsSortSortOrder?: 'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING', optionsSortSortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamAPIV1RetrieveChildTeamsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamAPIRetrieveChildTeams(teamId, optionsFilterQ, optionsPaginationOffset, optionsPaginationLimit, optionsSortSortOrder, optionsSortSortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a team
         * @param {string} teamId ID of the team to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamAPIRetrieveTeam(teamId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamAPIV1RetrieveTeamResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamAPIRetrieveTeam(teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets teams
         * @param {string} [optionsFilterQ] The query to filter on.
         * @param {number} [optionsPaginationOffset] Pagination offset.
         * @param {number} [optionsPaginationLimit] Result limit.
         * @param {'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING'} [optionsSortSortOrder] result order.   - SORT_ORDER_INVALID: Invalid default  - SORT_ORDER_ASCENDING: Ascending  - SORT_ORDER_DESCENDING: Descending
         * @param {string} [optionsSortSortBy] sort field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamAPIRetrieveTeams(optionsFilterQ?: string, optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsSortSortOrder?: 'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING', optionsSortSortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamAPIV1RetrieveTeamsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamAPIRetrieveTeams(optionsFilterQ, optionsPaginationOffset, optionsPaginationLimit, optionsSortSortOrder, optionsSortSortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the Users in a team
         * @param {string} teamId team id of team whose users will be retrieved
         * @param {string} [optionsFilterQ] The query to filter on.
         * @param {number} [optionsPaginationOffset] Pagination offset.
         * @param {number} [optionsPaginationLimit] Result limit.
         * @param {'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING'} [optionsSortSortOrder] result order.   - SORT_ORDER_INVALID: Invalid default  - SORT_ORDER_ASCENDING: Ascending  - SORT_ORDER_DESCENDING: Descending
         * @param {string} [optionsSortSortBy] sort field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamAPIRetrieveUsersForTeam(teamId: string, optionsFilterQ?: string, optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsSortSortOrder?: 'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING', optionsSortSortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamAPIV1RetrieveUsersForTeamResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamAPIRetrieveUsersForTeam(teamId, optionsFilterQ, optionsPaginationOffset, optionsPaginationLimit, optionsSortSortOrder, optionsSortSortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a team
         * @param {string} teamId ID of the team to be updated
         * @param {UpdateTeamRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamAPIUpdateTeam(teamId: string, body: UpdateTeamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamAPIV1UpdateTeamResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamAPIUpdateTeam(teamId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamAPIApi - factory interface
 * @export
 */
export const TeamAPIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamAPIApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds a user to a team
         * @param {string} teamId ID of the team under which the user should be added
         * @param {AddUserToTeamRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIAddUserToTeam(teamId: string, body: AddUserToTeamRequest, options?: any): AxiosPromise<object> {
            return localVarFp.teamAPIAddUserToTeam(teamId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a team
         * @param {TeamAPIV1CreateTeamRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPICreateTeam(body: TeamAPIV1CreateTeamRequest, options?: any): AxiosPromise<TeamAPIV1CreateTeamResponse> {
            return localVarFp.teamAPICreateTeam(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Moves a team to be a child of an existing team
         * @param {string} teamId ID of the team to be moved
         * @param {MoveTeamRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIMoveTeam(teamId: string, body: MoveTeamRequest, options?: any): AxiosPromise<TeamAPIV1MoveTeamResponse> {
            return localVarFp.teamAPIMoveTeam(teamId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes a team and all its sub-teams
         * @param {string} teamId ID of the team that will be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIRemoveTeam(teamId: string, options?: any): AxiosPromise<object> {
            return localVarFp.teamAPIRemoveTeam(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes a user from a team
         * @param {string} teamId ID of the team from which the user should be removed
         * @param {string} [userId] ID of the user to remove from the team.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIRemoveUserFromTeam(teamId: string, userId?: string, options?: any): AxiosPromise<object> {
            return localVarFp.teamAPIRemoveUserFromTeam(teamId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets child teams
         * @param {string} teamId ID of the team from which permissions should be retrieved
         * @param {string} [optionsFilterQ] The query to filter on.
         * @param {number} [optionsPaginationOffset] Pagination offset.
         * @param {number} [optionsPaginationLimit] Result limit.
         * @param {'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING'} [optionsSortSortOrder] result order.   - SORT_ORDER_INVALID: Invalid default  - SORT_ORDER_ASCENDING: Ascending  - SORT_ORDER_DESCENDING: Descending
         * @param {string} [optionsSortSortBy] sort field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIRetrieveChildTeams(teamId: string, optionsFilterQ?: string, optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsSortSortOrder?: 'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING', optionsSortSortBy?: string, options?: any): AxiosPromise<TeamAPIV1RetrieveChildTeamsResponse> {
            return localVarFp.teamAPIRetrieveChildTeams(teamId, optionsFilterQ, optionsPaginationOffset, optionsPaginationLimit, optionsSortSortOrder, optionsSortSortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a team
         * @param {string} teamId ID of the team to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIRetrieveTeam(teamId: string, options?: any): AxiosPromise<TeamAPIV1RetrieveTeamResponse> {
            return localVarFp.teamAPIRetrieveTeam(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets teams
         * @param {string} [optionsFilterQ] The query to filter on.
         * @param {number} [optionsPaginationOffset] Pagination offset.
         * @param {number} [optionsPaginationLimit] Result limit.
         * @param {'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING'} [optionsSortSortOrder] result order.   - SORT_ORDER_INVALID: Invalid default  - SORT_ORDER_ASCENDING: Ascending  - SORT_ORDER_DESCENDING: Descending
         * @param {string} [optionsSortSortBy] sort field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIRetrieveTeams(optionsFilterQ?: string, optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsSortSortOrder?: 'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING', optionsSortSortBy?: string, options?: any): AxiosPromise<TeamAPIV1RetrieveTeamsResponse> {
            return localVarFp.teamAPIRetrieveTeams(optionsFilterQ, optionsPaginationOffset, optionsPaginationLimit, optionsSortSortOrder, optionsSortSortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the Users in a team
         * @param {string} teamId team id of team whose users will be retrieved
         * @param {string} [optionsFilterQ] The query to filter on.
         * @param {number} [optionsPaginationOffset] Pagination offset.
         * @param {number} [optionsPaginationLimit] Result limit.
         * @param {'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING'} [optionsSortSortOrder] result order.   - SORT_ORDER_INVALID: Invalid default  - SORT_ORDER_ASCENDING: Ascending  - SORT_ORDER_DESCENDING: Descending
         * @param {string} [optionsSortSortBy] sort field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIRetrieveUsersForTeam(teamId: string, optionsFilterQ?: string, optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsSortSortOrder?: 'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING', optionsSortSortBy?: string, options?: any): AxiosPromise<TeamAPIV1RetrieveUsersForTeamResponse> {
            return localVarFp.teamAPIRetrieveUsersForTeam(teamId, optionsFilterQ, optionsPaginationOffset, optionsPaginationLimit, optionsSortSortOrder, optionsSortSortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a team
         * @param {string} teamId ID of the team to be updated
         * @param {UpdateTeamRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamAPIUpdateTeam(teamId: string, body: UpdateTeamRequest, options?: any): AxiosPromise<TeamAPIV1UpdateTeamResponse> {
            return localVarFp.teamAPIUpdateTeam(teamId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamAPIApi - object-oriented interface
 * @export
 * @class TeamAPIApi
 * @extends {BaseAPI}
 */
export class TeamAPIApi extends BaseAPI {
    /**
     * 
     * @summary Adds a user to a team
     * @param {string} teamId ID of the team under which the user should be added
     * @param {AddUserToTeamRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAPIApi
     */
    public teamAPIAddUserToTeam(teamId: string, body: AddUserToTeamRequest, options?: AxiosRequestConfig) {
        return TeamAPIApiFp(this.configuration).teamAPIAddUserToTeam(teamId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a team
     * @param {TeamAPIV1CreateTeamRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAPIApi
     */
    public teamAPICreateTeam(body: TeamAPIV1CreateTeamRequest, options?: AxiosRequestConfig) {
        return TeamAPIApiFp(this.configuration).teamAPICreateTeam(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Moves a team to be a child of an existing team
     * @param {string} teamId ID of the team to be moved
     * @param {MoveTeamRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAPIApi
     */
    public teamAPIMoveTeam(teamId: string, body: MoveTeamRequest, options?: AxiosRequestConfig) {
        return TeamAPIApiFp(this.configuration).teamAPIMoveTeam(teamId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes a team and all its sub-teams
     * @param {string} teamId ID of the team that will be removed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAPIApi
     */
    public teamAPIRemoveTeam(teamId: string, options?: AxiosRequestConfig) {
        return TeamAPIApiFp(this.configuration).teamAPIRemoveTeam(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes a user from a team
     * @param {string} teamId ID of the team from which the user should be removed
     * @param {string} [userId] ID of the user to remove from the team.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAPIApi
     */
    public teamAPIRemoveUserFromTeam(teamId: string, userId?: string, options?: AxiosRequestConfig) {
        return TeamAPIApiFp(this.configuration).teamAPIRemoveUserFromTeam(teamId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets child teams
     * @param {string} teamId ID of the team from which permissions should be retrieved
     * @param {string} [optionsFilterQ] The query to filter on.
     * @param {number} [optionsPaginationOffset] Pagination offset.
     * @param {number} [optionsPaginationLimit] Result limit.
     * @param {'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING'} [optionsSortSortOrder] result order.   - SORT_ORDER_INVALID: Invalid default  - SORT_ORDER_ASCENDING: Ascending  - SORT_ORDER_DESCENDING: Descending
     * @param {string} [optionsSortSortBy] sort field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAPIApi
     */
    public teamAPIRetrieveChildTeams(teamId: string, optionsFilterQ?: string, optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsSortSortOrder?: 'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING', optionsSortSortBy?: string, options?: AxiosRequestConfig) {
        return TeamAPIApiFp(this.configuration).teamAPIRetrieveChildTeams(teamId, optionsFilterQ, optionsPaginationOffset, optionsPaginationLimit, optionsSortSortOrder, optionsSortSortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a team
     * @param {string} teamId ID of the team to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAPIApi
     */
    public teamAPIRetrieveTeam(teamId: string, options?: AxiosRequestConfig) {
        return TeamAPIApiFp(this.configuration).teamAPIRetrieveTeam(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets teams
     * @param {string} [optionsFilterQ] The query to filter on.
     * @param {number} [optionsPaginationOffset] Pagination offset.
     * @param {number} [optionsPaginationLimit] Result limit.
     * @param {'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING'} [optionsSortSortOrder] result order.   - SORT_ORDER_INVALID: Invalid default  - SORT_ORDER_ASCENDING: Ascending  - SORT_ORDER_DESCENDING: Descending
     * @param {string} [optionsSortSortBy] sort field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAPIApi
     */
    public teamAPIRetrieveTeams(optionsFilterQ?: string, optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsSortSortOrder?: 'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING', optionsSortSortBy?: string, options?: AxiosRequestConfig) {
        return TeamAPIApiFp(this.configuration).teamAPIRetrieveTeams(optionsFilterQ, optionsPaginationOffset, optionsPaginationLimit, optionsSortSortOrder, optionsSortSortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the Users in a team
     * @param {string} teamId team id of team whose users will be retrieved
     * @param {string} [optionsFilterQ] The query to filter on.
     * @param {number} [optionsPaginationOffset] Pagination offset.
     * @param {number} [optionsPaginationLimit] Result limit.
     * @param {'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING'} [optionsSortSortOrder] result order.   - SORT_ORDER_INVALID: Invalid default  - SORT_ORDER_ASCENDING: Ascending  - SORT_ORDER_DESCENDING: Descending
     * @param {string} [optionsSortSortBy] sort field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAPIApi
     */
    public teamAPIRetrieveUsersForTeam(teamId: string, optionsFilterQ?: string, optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsSortSortOrder?: 'SORT_ORDER_INVALID' | 'SORT_ORDER_ASCENDING' | 'SORT_ORDER_DESCENDING', optionsSortSortBy?: string, options?: AxiosRequestConfig) {
        return TeamAPIApiFp(this.configuration).teamAPIRetrieveUsersForTeam(teamId, optionsFilterQ, optionsPaginationOffset, optionsPaginationLimit, optionsSortSortOrder, optionsSortSortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a team
     * @param {string} teamId ID of the team to be updated
     * @param {UpdateTeamRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamAPIApi
     */
    public teamAPIUpdateTeam(teamId: string, body: UpdateTeamRequest, options?: AxiosRequestConfig) {
        return TeamAPIApiFp(this.configuration).teamAPIUpdateTeam(teamId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserAPIApi - axios parameter creator
 * @export
 */
export const UserAPIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves the teams a user is on
         * @param {string} userId id of the user to retrieve the team of which they are a member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAPIRetrieveTeamsForUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userAPIRetrieveTeamsForUser', 'userId', userId)
            const localVarPath = `/api/v1/users/{userId}/teams`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve user retrieves a user\'s details
         * @param {string} id id of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAPIRetrieveUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userAPIRetrieveUser', 'id', id)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the users that belong to a specific org
         * @param {number} [optionsPaginationOffset] Pagination offset.
         * @param {number} [optionsPaginationLimit] Result limit.
         * @param {string} [optionsFilterQ] The query to filter on.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAPIRetrieveUsers: async (optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsFilterQ?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (optionsPaginationOffset !== undefined) {
                localVarQueryParameter['options.pagination.offset'] = optionsPaginationOffset;
            }

            if (optionsPaginationLimit !== undefined) {
                localVarQueryParameter['options.pagination.limit'] = optionsPaginationLimit;
            }

            if (optionsFilterQ !== undefined) {
                localVarQueryParameter['options.filter.q'] = optionsFilterQ;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserAPIApi - functional programming interface
 * @export
 */
export const UserAPIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserAPIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieves the teams a user is on
         * @param {string} userId id of the user to retrieve the team of which they are a member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAPIRetrieveTeamsForUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAPIV1RetrieveTeamsForUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAPIRetrieveTeamsForUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve user retrieves a user\'s details
         * @param {string} id id of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAPIRetrieveUser(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAPIV1RetrieveUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAPIRetrieveUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves the users that belong to a specific org
         * @param {number} [optionsPaginationOffset] Pagination offset.
         * @param {number} [optionsPaginationLimit] Result limit.
         * @param {string} [optionsFilterQ] The query to filter on.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAPIRetrieveUsers(optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsFilterQ?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAPIV1RetrieveUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAPIRetrieveUsers(optionsPaginationOffset, optionsPaginationLimit, optionsFilterQ, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserAPIApi - factory interface
 * @export
 */
export const UserAPIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserAPIApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieves the teams a user is on
         * @param {string} userId id of the user to retrieve the team of which they are a member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAPIRetrieveTeamsForUser(userId: string, options?: any): AxiosPromise<UserAPIV1RetrieveTeamsForUserResponse> {
            return localVarFp.userAPIRetrieveTeamsForUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve user retrieves a user\'s details
         * @param {string} id id of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAPIRetrieveUser(id: string, options?: any): AxiosPromise<UserAPIV1RetrieveUserResponse> {
            return localVarFp.userAPIRetrieveUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the users that belong to a specific org
         * @param {number} [optionsPaginationOffset] Pagination offset.
         * @param {number} [optionsPaginationLimit] Result limit.
         * @param {string} [optionsFilterQ] The query to filter on.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAPIRetrieveUsers(optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsFilterQ?: string, options?: any): AxiosPromise<UserAPIV1RetrieveUsersResponse> {
            return localVarFp.userAPIRetrieveUsers(optionsPaginationOffset, optionsPaginationLimit, optionsFilterQ, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserAPIApi - object-oriented interface
 * @export
 * @class UserAPIApi
 * @extends {BaseAPI}
 */
export class UserAPIApi extends BaseAPI {
    /**
     * 
     * @summary Retrieves the teams a user is on
     * @param {string} userId id of the user to retrieve the team of which they are a member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAPIApi
     */
    public userAPIRetrieveTeamsForUser(userId: string, options?: AxiosRequestConfig) {
        return UserAPIApiFp(this.configuration).userAPIRetrieveTeamsForUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve user retrieves a user\'s details
     * @param {string} id id of the user to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAPIApi
     */
    public userAPIRetrieveUser(id: string, options?: AxiosRequestConfig) {
        return UserAPIApiFp(this.configuration).userAPIRetrieveUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the users that belong to a specific org
     * @param {number} [optionsPaginationOffset] Pagination offset.
     * @param {number} [optionsPaginationLimit] Result limit.
     * @param {string} [optionsFilterQ] The query to filter on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAPIApi
     */
    public userAPIRetrieveUsers(optionsPaginationOffset?: number, optionsPaginationLimit?: number, optionsFilterQ?: string, options?: AxiosRequestConfig) {
        return UserAPIApiFp(this.configuration).userAPIRetrieveUsers(optionsPaginationOffset, optionsPaginationLimit, optionsFilterQ, options).then((request) => request(this.axios, this.basePath));
    }
}


